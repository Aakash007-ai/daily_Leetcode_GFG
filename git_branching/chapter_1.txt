learngitbranching.js

https://learngitbranching.js.org/?NODEMO --no demo link

//show commands  --- to list all commands

introduction 

git commits

a commit in a git repository records a sanpshot of all the (tracked) files in your directory. It is like a giant copy and paste, but even better!
Git wants to keep commits as lightweight as possible though, so it doesn't just blindly copy the entire directory every time you commit. It can (when possible) compress a commit as a set of changes, or a "delta", from one version of the repository to the next.
Git also maintains a history of which commits were made when. That's why most commits have ancestor commits above them -- we designate this with arrows in our visualization. Maintaining history is great for everyone working on the project!
It's a lot to take in, but for now you can think of commits as snapshots of the project. Commits are very lightweight and switching between them is wicked fast!


So, commit means creating a snapshot of changes that has been made and it references with some id we say git commit id.

on every commit the *main reassigned to new commit with new commit id 




git commit  //create snapshot of all data


Brancing in git 
Git Branches

Branches in Git are incredibly lightweight as well. They are simply pointers to a specific commit -- nothing more. This is why many Git enthusiasts chant the mantra:
branch early, and branch often
Because there is no storage / memory overhead with making many branches, it's easier to logically divide up your work than have big beefy branches.
When we start mixing branches and commits, we will see how these two features combine. For now though, just remember that a branch essentially says "I want to include the work of this commit and all parent commits."


git branch branchname

//it will create a new branch with branchname
the branch name refers to commit it was poitning pointing just before e.g commit c1
and is not active yet (if we do commit it will not commit in that branchname, it will continue after commit as c2 and branch name still refer to c1)


git cmmit //The main branch moved but the newImage branch didn't! That's because we weren't "on" the new branch, which is why the asterisk (*) was on main.


so tell git to checkout to branchname to workfrom there

git checkout branchame

git checkout -b branchname //create new branch and checkout to that branch 
//above command is equivalent to 2 commands i.e. git branch branchname + git checkout branchname




Merging in Git

Branches and Merging

Great! We now know how to commit and branch. Now we need to learn some kind of way of combining the work from two different branches together. This will allow us to branch off, develop a new feature, and then combine it back in.
The first method to combine work that we will examine is git merge. Merging in Git creates a special commit that has two unique parents. A commit with two parents essentially means "I want to include all the work from this parent over here and this one over here, and the set of all their parents."
It's easier with visuals, let's check it out in the next view.



git merge bugFix //merge current checkout branch with bugFix
//it will create a new commit pointing to both checkout and bugFix most recent commits


task-----
To complete this level, do the following steps:

Make a new branch called bugFix
Checkout the bugFix branch with git checkout bugFix
Commit once
Go back to main with git checkout
Commit another time
Merge the branch bugFix into main with git merge


git checkout -b bugfix; git commit ;git checkout main 
git commit; git merge bugFix 



Git Rebase

The second way of combining work between branches is rebasing. Rebasing essentially takes a set of commits, "copies" them, and plops them down somewhere else.
While this sounds confusing, the advantage of rebasing is that it can be used to make a nice linear sequence of commits. The commit log / history of the repository will be a lot cleaner if only rebasing is allowed.


//rebasing let believe development happens sequentially
suppose we have branch main(c2) and bugfix(c3) //both have parent commit c1

currently checkout to bugfix

we would like to move work from bugFix directly onto the work from main.
git rebase main

//
all commits of branch bugFix from where we create it or make it a new branch from parent are copied and gets append to main(c2) 

the only problem is that main is not get updated , it is still pointing to c2
//to solve this we do 
git rebase bugFix (while we are on main) 

git rebase bugFix (put current brnach next to )





HEAD

First we have to talk about "HEAD". HEAD is the symbolic name for the currently checked out commit -- it's essentially what commit you're working on top of.
HEAD always points to the most recent commit which is reflected in the working tree. Most git commands which make changes to the working tree will start by changing HEAD.
Normally HEAD points to a branch name (like bugFix). When you commit, the status of bugFix is altered and this change is visible through HEAD.



Detaching HEAD 
Detaching HEAD just means attaching it to a commit instead of a branch. This is what it looks like beforehand:

HEAD -> main -> C1

git checkout (commitid)





Relative Refs

Moving around in Git by specifying commit hashes can get a bit tedious. In the real world you won't have a nice commit tree visualization next to your terminal, so you'll have to use git log to see hashes.
Furthermore, hashes are usually a lot longer in the real Git world as well. For instance, the hash of the commit that introduced the previous level is fed2da64c0efc5293610bdd892f82a58e8cbc5d8. Doesn't exactly roll off the tongue...
The upside is that Git is smart about hashes. It only requires you to specify enough characters of the hash until it uniquely identifies the commit. So I can type fed2 instead of the long string above.



Like I said, specifying commits by their hash isn't the most convenient thing ever, which is why Git has relative refs. They are awesome!
With relative refs, you can start somewhere memorable (like the branch bugFix or HEAD) and work from there.
Relative commits are powerful, but we will introduce two simple ones here:
Moving upwards one commit at a time with ^
Moving upwards a number of times with ~<num>



Let's look at the Caret (^) operator first. Each time you append that to a ref name, you are telling Git to find the parent of the specified commit.
So saying main^ is equivalent to "the first parent of main".
main^^ is the grandparent (second-generation ancestor) of main
Let's check out the commit above main here.


git checkout bugfix^ //make head move to parent of bugFix
git checkout bugFix^^ //make head move to great-grand parnet of bugFix

git checkout bugFix~4 //if bugfix is at c4 it will move head to c0 at 4th head starting from above as 1



Branch Forcing

You're an expert on relative refs now, so let's actually use them for something.
One of the most common ways I use relative refs is to move branches around. You can directly reassign a branch to a commit with the -f option. So something like:
git branch -f main HEAD~3
moves (by force) the main branch to three parents behind HEAD.
Note: In a real git environment git branch -f command is not allowed for your current branch.

git branch -f move_that_branch(branch_name) commit_id/HEAD/commit_head/main^




Reversing changes in git 

There are many ways to reverse changes in Git. And just like committing, reversing changes in Git has both a low-level component (staging individual files or chunks) and a high-level component (how the changes are actually reversed). Our application will focus on the latter.
There are two primary ways to undo changes in Git -- one is using git reset and the other is using git revert. We will look at each of these in the next dialog


Git Reset 

git reset reverses changes by moving a branch reference backwards in time to an older commit. In this sense you can think of it as "rewriting history;" git reset will move a branch backwards as if the commit had never been made in the first place.
Let's see what that looks like:
Nice! Git moved the main branch 


git reset HEAD^

GIT Revert 

While resetting works great for local branches on your own machine, its method of "rewriting history" doesn't work for remote branches that others are using.
In order to reverse changes and share those reversed changes with others, we need to use git revert. Let's see it in action.

git revert HEAD 

//
Weird, a new commit plopped down below the commit we wanted to reverse. That's because this new commit C2' introduces changes -- it just happens to introduce changes that exactly reverses the commit of C2.
With reverting, you can push out your changes to share with others.



Moving WOrk Around 
So far we've covered the basics of git -- committing, branching, and moving around in the source tree. Just these concepts are enough to leverage 90% of the power of git repositories and cover the main needs of developers.
That remaining 10%, however, can be quite useful during complex workflows (or when you've gotten yourself into a bind). The next concept we're going to cover is "moving work around" -- in other words, it's a way for developers to say "I want this work here and that work there" in precise, eloquent, flexible ways.
This may seem like a lot, but it's a simple concept.


Git Cherry-Pick

The first command in this series is called git cherry-pick. It takes on the following form:

git cherry-pick <Commit1> <Commit2> <...>
It's a very straightforward way of saying that you would like to copy a series of commits below your current location (HEAD). I personally love cherry-pick because there is very little magic involved and it's easy to understand.

git cherry-pick C2 C4 //pull all commit next to HEAD then C4 and update head 
///all will be have new commit id C2` C4` 
C2 AND C4 may be from any branch 





GIT Interactive Rebase 

All interactive rebase means Git is using the rebase command with the -i option.
If you include this option, git will open up a UI to show you which commits are about to be copied below the target of the rebase. It also shows their commit hashes and messages, which is great for getting a bearing on what's what.
For "real" git, the UI window means opening up a file in a text editor like vim.


e.g.

git rebase -i HEAD~4
//it will open a interactive dialog
//homework select and get hands on



Locally Stacked Commits

Here's a development situation that often happens: I'm trying to track down a bug but it is quite elusive. In order to aid in my detective work, I put in a few debug commands and a few print statements.
All of these debugging / print statements are in their own commits. Finally I track down the bug, fix it, and rejoice!
Only problem is that I now need to get my bugFix back into the main branch. If I simply fast-forwarded main, then main would get all my debug statements which is undesirable. There has to be another way...


problem statemet :----
suppose we know that we have a undiscovered bugs in our code , so we make a separate bugfix branch,
so in first commit we add all our logs/printf_statement/console.log / just to find that bug 
now we have find that bug and wanted to get only that commit where we altered code to find bugs 

so we have 2 option 
git rebase -1 commit_to_pick_up
git cherry-pick

//by interactive 
git rebase -i HEAD~4 //from current branch move to that branch where we have to add changes 
//omit those commits that are not required
git branch -f main //move that branch to current head i.e. new commit of rebase