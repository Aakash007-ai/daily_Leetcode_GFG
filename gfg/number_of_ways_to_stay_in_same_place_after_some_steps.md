<div><h2>Solution</h2>
<hr>
<h4 id="approach-1-topdown-dynamic-programming">Approach 1: Top-Down Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<blockquote>
<p><strong>Note.</strong> For this approach, we assume that you already know the fundamentals of dynamic programming and are figuring out how to apply it to a wide range of problems, such as this one. If you are not yet at this stage, we recommend checking out our relevant <a href="https://leetcode.com/explore/featured/card/dynamic-programming/">Explore Card content on dynamic programming</a> before coming back to this problem.</p>
</blockquote>
<p>Let's imagine that we are positioned on a number line. This number line starts at <code>0</code> and ends at <code>arrLen - 1</code> (since <code>arrLen</code> is 0-indexed). We start at <code>0</code> on this number line, and on each move we are allowed to move left, right, or stay.</p>
<p>We start at <code>0</code>, need to make <code>steps</code> moves, and want to end up back at <code>0</code>. Without loss of generality, let's say we are currently at <code>curr</code> on the number line and need to make <code>remain</code> more moves. We have three options:</p>
<ol>
<li>Don't move. We will stay at <code>curr</code> and need to make <code>remain - 1</code> more moves.</li>
<li>Move left. We can only do this if <code>curr &gt; 0</code>. We move to <code>curr - 1</code> and need to make <code>remain - 1</code> more moves.</li>
<li>Move right. We can only do this if <code>curr &lt; arrLen - 1</code>. We move to <code>curr + 1</code> and need to make <code>remain - 1</code> more moves.</li>
</ol>
<p>Let's define a function <code>dp(curr, remain)</code> that returns the number of ways we can arrive at <code>0</code> from <code>curr</code> after <code>remain</code> moves. If we want to go back to <code>0</code>, we can only do so through one of these three options. In other words, the number of ways to return to <code>0</code> from the current state is equivalent to the sum of the number of ways to return to <code>0</code> in the next three options. We have the following transitions:</p>
<ol>
<li><code>dp(curr, remain) += dp(curr, remain - 1)</code></li>
<li><code>dp(curr, remain) += dp(curr - 1, remain - 1) if curr &gt; 0</code></li>
<li><code>dp(curr, remain) += dp(curr + 1, remain - 1) if curr &lt; arrLen - 1&gt;</code></li>
</ol>
<p>What will be the base case of this function? If <code>remain = 0</code>, we have no more moves to make. If <code>curr = 0</code>, then we have found a way to accomplish our task, so we <code>return 1</code>. Otherwise, we return <code>0</code>.</p>
<p>This recursive approach will solve the problem, but will have an exponential time complexity as each call to <code>dp</code> creates three more calls. Many states of <code>curr, remain</code> will be repeated. In the below tree, each node represents a call to <code>dp</code> with the first number being <code>curr</code> and the second one being <code>steps</code>. Nodes with the same color represent the same arguments. With larger values of <code>steps</code> and <code>arrLen</code>, the tree will quickly grow beyond what we can compute.</p>
<p><img src="../Figures/1269/1.png" alt="img">
<br></p>
<p>To prevent repeated computation, we will memoize the <code>dp</code> function. Using a data structure <code>memo</code>, the first time we find the answer for a state <code>curr, remain</code>, we will save it in <code>memo</code>. In the future when we see the same <code>curr, remain</code> state again, we can refer to <code>memo</code> instead of having to re-calculate. With memoization, the tree now looks like this:</p>
<p><img src="../Figures/1269/2.png" alt="img">
<br></p>
<p>If we want to use a 2D array to implement <code>memo</code>, we must be careful with the sizing. Notice in the constraints that while <code>steps</code> can be up to <code>500</code>, <code>arrLen</code> can be up to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>. However, it is impossible for any call to have a value of <code>curr</code> greater than <code>steps</code>. The furthest we can go is by only making moves to the right, but we would run out of moves after <code>steps</code> moves. Thus, we can safely perform <code>arrLen = min(arrLen, steps)</code> before starting the algorithm.</p>
<p>The answer to the original problem is <code>dp(0, steps)</code>. We start at <code>0</code> and need to make <code>steps</code> moves.</p>
<p><strong>Algorithm</strong></p>
<p>All arithmetic operations should be done mod <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9 + 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>.</p>
<ol>
<li>Create a memoized function <code>dp(curr, remain)</code>:
<ul>
<li>If <code>remain == 0</code>:
<ul>
<li>Return <code>1</code> if <code>curr == 0</code>, and <code>0</code> otherwise.</li>
</ul>
</li>
<li>Initialize <code>ans = dp(curr, remain - 1)</code>.</li>
<li>If <code>curr &gt; 0</code>, add <code>dp(curr - 1, remain - 1)</code> to <code>ans</code>.</li>
<li>If <code>curr &lt; arrLen - 1</code>, add <code>dp(curr + 1, remain - 1)</code> to <code>ans</code>.</li>
<li>Return <code>ans</code>.</li>
</ul>
</li>
<li>Set <code>arrLen = min(arrLen, steps)</code>.</li>
<li>Return <code>dp(0, steps)</code>.</li>
</ol>
<p>To memoize <code>dp</code>:</p>
<ol>
<li>After the base case, check if <code>curr, remain</code> has already been calculated using a data structure <code>memo</code>.
<ul>
<li>If it has already been calculated, return the saved result.</li>
</ul>
</li>
<li>Before returning <code>ans</code>, store <code>ans</code> in <code>memo</code> while associating it with <code>curr, remain</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
<p>In Python, we use <a href="https://docs.python.org/3/library/functools.html#functools.cache" rel="ugc">@functools.cache</a> to memoize our function.</p>
</blockquote>
<iframe src="https://leetcode.com/playground/GT3i8Y69/shared" frameborder="0" width="100%" height="500" name="GT3i8Y69"></iframe>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> as <code>steps</code> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> as <code>arrLen</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot \min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span></p>
<p>There can be <code>steps</code> values of <code>remain</code> and <code>min(steps, arrLen)</code> values of <code>curr</code>. The reason <code>curr</code> is limited by <code>steps</code> is because if we were to only move right, we would eventually run out of moves. Thus, there are <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot \min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span> states of <code>curr, remain</code>. Due to memoization, we never calculate a state more than once. To calculate a given state costs <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> as we are simply adding up three options.</p>
</li>
<li>
<p>Space complexity: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot \min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span></p>
<p>The recursion call stack uses up to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> space, but this is dominated by <code>memo</code> which has a size of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot \min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span>.</p>
</li>
</ul>
<br>
<hr>
<h4 id="approach-2-bottomup-dynamic-programming">Approach 2: Bottom-Up Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<p>The "answer state" is <code>curr = 0, remain = steps</code>. In the previous approach, we started by making a call to <code>dp(0, steps)</code> and made function calls down to the base case. In this approach, we will start at the base case and iterate toward the answer state.</p>
<p>To implement this iterative algorithm, we will convert <code>dp</code> from a function to an array. Here, <code>dp[curr][remain]</code> is analogous to <code>dp(curr, remain)</code> from the previous approach.</p>
<p>First, we need to size <code>dp</code>. The first dimension needs to be the range of <code>curr</code>. As the number line has a limit of <code>arrLen - 1</code>, the first dimension of <code>dp</code> should have a size of <code>arrLen</code>. As we mentioned briefly in the previous approach, the value of <code>arrLen</code> can be reduced to <code>min(arrLen, steps)</code>. Larger values of <code>arrLen</code> (greater than <code>steps</code>) are pointless because we could not reach those states due to running out of <code>steps</code>. The second dimension of <code>dp</code> needs to be the range of <code>remain</code>. As the maximum value of <code>remain</code> is <code>steps</code>, the second dimension of <code>dp</code> should have a size of <code>steps + 1</code>. Thus, dp will have a size of <code>arrLen * (steps + 1)</code> (after we update <code>arrLen = min(arrLen, steps)</code>).</p>
<p>Second, we need to initialize the base case. Assuming <code>dp</code> is initialized with values of <code>0</code>, the only non-zero base case is when <code>curr = 0, remain = 0</code>, the answer is <code>1</code>. Thus, we will set <code>dp[0][0] = 1</code>.</p>
<p>Third, we need to configure our for-loops. We will use nested for-loops to iterate over all states of <code>curr, remain</code>. We must iterate starting from the base case. Thus, our first loop will be over <code>remain</code> starting at <code>1</code> and ending at <code>steps</code>. Our second loop will be over <code>curr</code> starting at <code>arrLen - 1</code> and ending at <code>0</code>.</p>
<blockquote>
<p>Generally, you want the final loop iteration to calculate the final answer. As our answer state is <code>curr = 0, remain = steps</code>, we have the loop for <code>remain</code> end at <code>steps</code> and the loop for <code>curr</code> end at <code>0</code>.</p>
</blockquote>
<p>Finally, each inner loop iteration represents a state <code>curr, remain</code>. We will calculate its value <code>dp[curr][remain]</code> just like we did in the previous approach by considering the three options:</p>
<ol>
<li>Don't move. Add <code>dp[curr][remain - 1]</code>.</li>
<li>Move left. We can only do this if <code>curr &gt; 0</code>. Add <code>dp[curr - 1][remain - 1]</code>.</li>
<li>Move right. We can only do this if <code>curr &lt; arrLen - 1</code>. Add <code>dp[curr + 1][remain - 1]</code>.</li>
</ol>
<p>The answer to the original problem is <code>dp[0][steps]</code>. We return this value at the end.</p>
<p><strong>Algorithm</strong></p>
<p>All arithmetic operations should be done mod <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9 + 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>.</p>
<ol>
<li>Set <code>arrLen = min(arrLen, steps)</code>.</li>
<li>Create an array <code>dp[arrLen][steps + 1]</code>.</li>
<li>Set <code>dp[0][0] = 1</code>, the base case.</li>
<li>Iterate <code>remain</code> from <code>1</code> to <code>steps</code>:
<ul>
<li>Iterate <code>curr</code> from <code>arrLen - 1</code> to <code>0</code>:
<ul>
<li>Initialize <code>ans = dp[curr][remain - 1]</code>.</li>
<li>If <code>curr &gt; 0</code>, add <code>dp[curr - 1][remain - 1]</code> to <code>ans</code>.</li>
<li>If <code>curr &lt; arrLen - 1</code>, add <code>dp[curr + 1][remain - 1]</code> to <code>ans</code>.</li>
<li>Set <code>dp[curr][remain] = ans</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <code>dp[0][steps]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<iframe src="https://leetcode.com/playground/5vpRC8jN/shared" frameborder="0" width="100%" height="500" name="5vpRC8jN"></iframe>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> as <code>steps</code> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> as <code>arrLen</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot \min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span></p>
<p>Our nested for-loops iterate over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot \min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span> states of <code>curr, remain</code>. Calculating each state is done in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
</li>
<li>
<p>Space complexity: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot \min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span></p>
<p><code>dp</code> has a size of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot \min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span>.</p>
</li>
</ul>
<br>
<hr>
<h4 id="approach-3-spaceoptimized-dynamic-programming">Approach 3: Space-Optimized Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<p>You may notice that in the previous two approaches, to calculate a state <code>curr, remain</code>, we only needed states involving <code>remain - 1</code>. For example, if we wanted to calculate <code>dp[4][6]</code>, we only needed values of <code>dp[...][5]</code>. Values stored in <code>dp[...][4], dp[...][3], dp[...][2]</code>, etc. are no longer required.</p>
<p>As we iterate over <code>remain</code> using the outer for-loop, we only need to store values of <code>dp</code> for the current value of <code>remain</code> and the previous value <code>remain - 1</code>. We will use two arrays of size <code>arrLen</code> to do this: <code>dp</code> and <code>prevDp</code>.</p>
<p>Here, <code>dp[curr]</code> is analogous to <code>dp[curr][remain]</code> from the previous approach. <code>prevDp[curr]</code> is analogous to <code>dp[curr][remain - 1]</code> from the previous approach.</p>
<p>As the first value of <code>remain = 1</code>, this means initially, <code>prevDp</code> represents values for <code>remain = 0</code>. This means we must initialize <code>prevDp[0]</code>, as this is our base case <code>curr = 0, remain = 0</code>.</p>
<p>At the beginning of each outer for-loop iteration, we will reset <code>dp</code>. We will then calculate <code>dp</code> using values from <code>prevDp</code>. Once we have finished calculating <code>dp</code>, we will update <code>prevDp = dp</code>, so that in the next iteration, <code>prevDp</code> will represent the correct values.</p>
<p>For example, when <code>remain = 5</code>:</p>
<ol>
<li><code>dp[curr]</code> represents <code>dp[curr][5]</code> from the previous approach. We calculate it using <code>prevDp</code>, where <code>prevDp[curr]</code> represents <code>prevDp[curr][4]</code> from the previous approach.</li>
<li>Once we finish calculating <code>dp</code>, the next for-loop iteration has <code>remain = 6</code>, and now <code>prevDp</code> must represent values of <code>remain = 5</code>.</li>
<li>This is why we update <code>prevDp = dp</code>, since we just calculated <code>dp</code> to have the values for <code>remain = 5</code>.</li>
</ol>
<p>The final value we have in our for-loop over <code>remain</code> is <code>steps</code>. Thus, the final calculated <code>dp</code> will represent values for <code>remain = steps</code>. We can simply return <code>dp[0]</code>, which represents <code>dp[0][steps]</code> from the previous approach, our answer state.</p>
<p><strong>Algorithm</strong></p>
<p>All arithmetic operations should be done mod <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9 + 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>.</p>
<ol>
<li>Set <code>arrLen = min(arrLen, steps)</code>.</li>
<li>Create an array <code>dp[arrLen]</code> and an array <code>prevDp[arrLen]</code>.</li>
<li>Set <code>prevDp[0] = 1</code>, the base case.</li>
<li>Iterate <code>remain</code> from <code>1</code> to <code>steps</code>:
<ul>
<li>Reset <code>dp</code>.</li>
<li>Iterate <code>curr</code> from <code>arrLen - 1</code> to <code>0</code>:
<ul>
<li>Initialize <code>ans = prevDp[curr]</code>.</li>
<li>If <code>curr &gt; 0</code>, add <code>prevDp[curr - 1]</code> to <code>ans</code>.</li>
<li>If <code>curr &lt; arrLen - 1</code>, add <code>prevDp[curr + 1]</code> to <code>ans</code>.</li>
<li>Set <code>dp[curr] = ans</code>.</li>
</ul>
</li>
<li>Update <code>prevDp = dp</code>.</li>
</ul>
</li>
<li>Return <code>dp[0]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<iframe src="https://leetcode.com/playground/npzaJiJR/shared" frameborder="0" width="100%" height="500" name="npzaJiJR"></iframe>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> as <code>steps</code> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> as <code>arrLen</code>,</p>
<ul>
<li>
<p>Time complexity: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot \min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span></p>
<p>Our nested for-loops iterate over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>⋅</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot \min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span> states of <code>curr, remain</code>. Calculating each state is done in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
</li>
<li>
<p>Space complexity: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span></p>
<p><code>dp</code> and <code>prevDp</code> have a size of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>min</mi><mo>⁡</mo><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\min{(n, m)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span>.</p>
</li>
</ul>
<br>
<hr>
</div>